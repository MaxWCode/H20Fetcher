package main

import (
	"encoding/csv"
	"fmt"
	"io" // Use this instead of "io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

// PostcodeResult holds the result for each postcode lookup
type PostcodeResult struct {
	Postcode string
	Supplier string
}

func main() {
	// Sample list of postcodes (will later be replaced with postcodes from the CSV)
	postcodes := []string{"TR19 7AU", "AB10 1AB"}

	// Channel to collect results
	results := make(chan PostcodeResult)

	// Create a rate limiter using a ticker (e.g., 1 request per second)
	rateLimiter := time.NewTicker(1 * time.Second)
	defer rateLimiter.Stop()

	// Channel to control the number of concurrent goroutines (e.g., 5 in this case)
	concurrencyLimit := 5
	semaphore := make(chan struct{}, concurrencyLimit)

	// Iterate over each postcode and start a goroutine for each
	for _, postcode := range postcodes {
		// Acquire a spot in the semaphore before starting a new goroutine
		semaphore <- struct{}{}

		go func(postcode string) {
			// Wait for the rate limiter before making a request
			<-rateLimiter.C

			// Perform the postcode lookup
			supplier := getSupplierForPostcode(postcode)

			// Send the result back through the channel
			results <- PostcodeResult{Postcode: postcode, Supplier: supplier}

			// Release the spot in the semaphore
			<-semaphore
		}(postcode)
	}

	// Collect results in a slice
	var allResults []PostcodeResult

	// Read the results from the channel
	for range postcodes {
		result := <-results
		allResults = append(allResults, result)
	}

	// Save results to a CSV file
	saveResultsToCSV(allResults)
	fmt.Println("Water supplier lookup completed and results saved to water_suppliers.csv")
}

// getSupplierForPostcode performs the POST request to get the supplier info for a given postcode
func getSupplierForPostcode(postcode string) string {
	// Target URL of the POST request
	endpointURL := "https://www.water.org.uk/customers/find-your-supplier?ajax_form=1&_wrapper_format=drupal_ajax"

	// Data payload for the POST request
	formData := url.Values{
		"postcode":                  {postcode},
		"form_build_id":             {"form-3MUnYZREwcwLnFkUa2pcdYLPnuxq-AqplFCuzLnPtMw"}, // Update as needed
		"form_id":                   {"wateruk_find_my_supplier"},
		"_triggering_element_name":  {"op"},
		"_triggering_element_value": {"Submit"},
		"_drupal_ajax":              {"1"},
		"ajax_page_state[theme]":    {"wateruk_theme"},
	}

	// Create the POST request
	req, err := http.NewRequest("POST", endpointURL, strings.NewReader(formData.Encode()))
	if err != nil {
		log.Printf("Error creating request for postcode %s: %v", postcode, err)
		return "Error"
	}

	// Set headers for the request
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
	req.Header.Set("User-Agent", "Mozilla/5.0 (compatible)")

	// Perform the POST request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("Error sending request for postcode %s: %v", postcode, err)
		return "Error"
	}
	defer resp.Body.Close()

	// Check if the request was successful
	if resp.StatusCode != http.StatusOK {
		log.Printf("Received non-OK HTTP status for postcode %s: %s", postcode, resp.Status)
		return "Error"
	}

	// Read and process the response body using io.ReadAll
	body, err := io.ReadAll(resp.Body) // Updated from ioutil.ReadAll
	if err != nil {
		log.Printf("Error reading response for postcode %s: %v", postcode, err)
		return "Error"
	}

	// Simulate extracting supplier information from the JSON response (adjust parsing as necessary)
	if strings.Contains(string(body), "supplier-info") {
		return "Supplier Found"
	}

	return "Not Found"
}

// saveResultsToCSV writes the postcode results to a CSV file
func saveResultsToCSV(results []PostcodeResult) {
	file, err := os.Create("water_suppliers.csv")
	if err != nil {
		log.Fatalf("Failed to create file: %v", err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Write the header row
	writer.Write([]string{"Postcode", "Supplier"})

	// Write all records to the CSV
	for _, result := range results {
		if err := writer.Write([]string{result.Postcode, result.Supplier}); err != nil {
			log.Fatalf("Error writing record to CSV: %v", err)
		}
	}
}
